# 深入理解计算机系统 精华荟萃
## 第一章：计算机系统漫游
1. c程序**编译**整体流程（p3）

2. **储存**设备形成金字塔层次结构（p10）

## 第二部分：程序结构和执行
### 第2章：信息的表示和处理
1. **字**的大小代表限制可寻址的虚拟地址空间大小（p27）

2. **大端小端**的存储方式(p29)

3. **补码**编码的定义，有符号数编码与无符号数编码（补码）之间的转换(p45，p49)

4. c语言中**不同整数类型的转换**（p52~p60）
  - 4.1 无符号数与有符号数的转换
  - 4.2 扩展位的转换（零扩展与符号扩展）
  - 4.3 截断位的转换

5. IEEE**浮点数**编码标准(p78)

### 第3章：程序的机器级表示
1. 汇编（gcc -S）与反汇编(objdump)与生成的汇编代码的细微差别(p114)

2. ATT与intel汇编代码格式(p118)

3. x86-64机器的16个64位寄存器(p120)与4个条件码寄存器(p135)和其默认功能

4. x86-64机器指令讲解
  - 4.1 操作数指示符与5个指令后缀（‘b’,'w','l','q','o'）--(1, 2, 4, 8, 16)
  - 4.2 基础操作指令（mov、lea、栈操作、加减乘除、移位、逻辑操作）
  - 4.3 只改变条件码寄存器的指令（cmp、test）与依据条件码执行的设置(set)、跳转(j..,jmp不依赖条件码)、传送(cmov)

5. 汇编链接阶段跳转指令的目标有两种编码方式---PC**相对地址与绝对地址**(P140)

6. **条件数据传送与条件控制转移**的原理与性能分析(p145)

7. 常见**控制块**(while、for、do...while、switch)的汇编指令形式(p149)

8. 函数调用前后**栈内存**的使用（传递参数、局部变量、被调用者保存寄存器等）（p164）

9. **数据对齐**的缘由与其在结构体、联合等数据结构中的具体表现（p191）

10. **指针要点**分析(p192) 

11. gdb使用(p193)

12. **缓冲区溢出攻击**的原理以及如今gcc上的三种应对方法（病毒与蠕虫的区别）p195

13. x86-64机器指令架构中的浮点指令与寄存器(p204)

### 第4章：处理器体系结构
1. RISC与CISC指令集(p249)

2. 硬件控制语言(HCL)p256

### 第5章：优化程序性能
1. 编译器的固有**局限**
  - 内存别名使用
  - 函数调用(可以使用内联函数替换来优化函数调用)

2. **CPE**(Cycles Per Element)度量与手动优化代码的方式
  - 代码移动
  - 减少过程调用
  - 消除不必要的内存引用

3. **最小二乘**拟合

4. **乱序**处理器的基本原理（分支预测技术等）

5. 理解处理器各种运算的**延迟界限**与**吞吐量界限**(分别与处理器运算的延迟与发射时间、容量相关)

6. 观察数据流图，进一步**提高效率**的方法(突破延迟界限)
  - 循环展开(减少循环开支)
  - 多个累积变量(数据并行处理最后合并结果)
  - 重新结合变换(通过变换求值顺序来提高指令并行度，主路径上的指令与旁支上的并行执行)

7. 可能会**限制程序执行效率**的一些因素
  - 寄存器溢出（会占用内存来进行数据的存储，而从内存中进行数据的存取与寄存器不在一个数量级）
  - 分支预测错误处罚（尽量使用条件传送而不是条件分支）

8. **程序分析**工具`gpref`使用流程与应用
  - `gcc -pg test.c -o test`主要是加上`-pg`参数
  - 先运行程序`./test`，程序运行完会生成`gmon.out`
  - `gprof ./test gmon.out -b`可查看输出

### 第6章：存储器层次结构
1. 随机访问存储器(RAM) p400
  - SRAM
  - DRAM(包括内存模块结构)

2. 非易失性存储器 (p404)
  - 固态硬盘(SSD) p414
  - 磁盘(p406)

3. 处理器的存储**访问**
  - 内存总线(p405)
  - IO总线(p412)

4. 存储技术的**发展趋势**(p415)

5. **局部性**的意义(p418)
  - 空间局部性
  - 时间局部性

6. 存储器层次结构(那张图p421)

7. **缓存管理**的概念(p422)
  - 缓存命中
  - 缓存不命中
      - 强制性（冷）不命中
      - 冲突不命中
      - 容量不命中

8. 通用的高速缓存存储器**组织结构**(S, E, B, m) p425
  - 直接映射高速缓存(E=1)的缓存管理(p428)
  - 组相联高速缓存（E>1）的缓存管理(p433)
  - 全相联高速缓存（S=1）的缓存管理(p434)

9. 缓存写的问题(p437)
  - 直写与非写分配
  - 写回与写分配

10. 高速缓存层次结构与性能的影响因素(p438)

11. 缓存的性能山与利用好空间局部与时间局部的编程。

### 第七章: 链接
1. 链接器的主要任务：构造可执行文件(p466)
  - **符号解析**：将每个符号引用与一个符号定义关联起来
  - **重定位**：将每个符号定义与一个内存位置关联起来。
      - 重定位节与符号定义
      - 重定位节中的符号引用

2. 目标文件的**种类**(p466)
  - 可重定位目标文件
  - 可执行目标文件
  - 共享目标文件

3. 强符号与弱符号
  - 函数与已初始化的全局变量是**强符号**
  - 未初始化的全局变量是**弱符号**

4. **解析**多重定义的全局符号**规则**(p471)
  - 不允许有多个同名的强符号
  - 如果有一个强符号与多个弱符号同名，那么选择强符号
  - 如果有多个弱符号同名，那么从弱符号中任意选择一个。

5. 在命令行上输入可重定位目标文件与存档文件时需要注意**依赖顺序**(p477 7.6.3)

6. 重定位条目与使用其进行重定义符号引用（P479）

7. 静态库与动态库的特性与使用
  - 位置无关代码PIC
  - 库打桩
      - 编译时
      - 链接时
      - 运行时

### 第八章：异常控制流
1. **异常**：是控制流中的突变，用来响应某些变化。主要有以下四类; p502　p504
    - 中断:　来自IO设备的信号，异步，中断处理完毕返回到下一条指令
    - 陷阱:　主动有意的异常，同步，陷阱处理完毕返回到下一条指令
    - 故障:　潜在的可恢复的错误，同步，处理完毕可能返回到当前指令
    - 终止:　不可恢复的错误，同步，不会返回

2. 理解广义的异常与一些编程语言中的狭义的异常　p503

3. 了解x86-64架构的linux系统各自定义的异常　p506

4. 并发与并行的区别。 p509

5. 熟悉unix提供给c语言的系统调用**接口函数**　
    - 进程 p513　（可以使用fork与execve函数模拟一个简单的shell）
        - fork函数：复制出子进程，调用一次返回两次
        - waitpid函数：回收子进程
        - execve函数：在当前进程的上下文加载并运行别处的程序
    - 信号　p530
        - kill函数、alarm函数：发送信号
        - signal函数：接受信号，设置与信号相关联的行为（可移植的包装函数版本是Signal函数）
        - sigprocmask函数：阻塞与解除阻塞信号，设置当前阻塞的信号集合

6. unix信号类型　p527

7. 为了正确、安全、可移植的信号处理中要注意的问题（其中并发问题很重要）　p534

8. 理解非本地跳转(结合c++中的异常机制)：如何使用其来规避正常的调用/返回栈规则 　p547
    - setjmp函数类似try语句中的catch子句
    - longjmp函数类似于throw语句

### 第九章：虚拟内存
> 在现代计算机中，数据的读写一般是严格按照存储器层次结构进行的．比如处理器的运算单元从寄存器读取数据，寄存器从缓存读取数据，缓存从内存读取数据，内存从硬盘读取数据．当运算单元需要的数据寄存器中没有时，寄存器便会从缓存中请求该数据；如果缓存中也没有该数据，缓存便会从内存中请求该数据；如果内存中也没有该数据，内存便会从硬盘上请求该数据；

1. 虚拟内存中的**基本概念**：
    - 页表，页表条目(PTE)　　p563图9-1
    - 内存是按页（或者块）进行传输管理的，虚拟页(VP)，物理页(PP)
    - 内存管理单元（MMU）,翻译后备缓冲器(TLB)  p570
    
2. 虚拟内存使用的**好处**:
    - 内存管理上  p565
    - 安全性上  p567

3. 每一个进程都有一个独立的虚拟地址空间，一般程序使用的虚拟地址首先通过MMU翻译成物理地址，然后再通过物理地址到最近一级的存储上(此处时L1缓存，因为寄存器不是按地址访问的)访问．
    - **地址翻译**：地址翻译是通过页表进行的，如果不命中，在地址翻译的过程中也完成了将数据从底层的存储（比如硬盘）到高层的存储(比如L1缓存)的转移．
    - 完整的过程：　p571

4. **多级页表**的原理与作用(通过多级可以解决单个页表过大的情况)  p571

5. 不同进行对同一段物理内存进行**内存映射**时共享对象与私有对象的处理区别  p583
    - 共享对象对共享区域的任何写操作对其他进程是可见的
    - 私有对象对共享区域的任何写操作对其他进程不可见（由于写时复制）
    - 理解fork函数与execve函数     p584

6. 理解**动态内存分配**如何创建与删除虚拟内存的区域       p587
    - 堆的碎片问题        p591
    - 堆的空间组织问题

7. 垃圾收集问题与c程序中常见的内存相关错误     p605

### 第十章：系统级I/O
1. **I/O**就是输入与输出，操作对象为I/O设备(在linux都被模型化为**文件**)
    - Unix I/O，内核提供的文件操作的接口     p622
    - 文件    p623

2. linux的关于io接口的**系统调用**
    - open,close,read,write     p624
    - 读取目录，元数据      p632
    - I/O重定向        p637

3. **RIO**(Robust I/O)包     p627

4. **共享文件**原理       p634

5. c语言提供的标准I/O库     p638

### 第十一章：网络编程
1. 网络       p643
    - 以太网通过集线器互联
    - 较大局域网通过桥接以太网构成
    - 互联网（广域网）通过路由器连接多个不兼容的局域网
    - 互联网中不同局域网的两台主机传输数据的八个步骤       p645

2. IP与域名
    - dns映射关系       p650

3. 套接字socket
    - 从内核角度看一个套接字是通信的一个端点，从程序看套接字是一个相应描述符的打开文件
    - 监听描述符与已连接描述符的区别       p656

4. web服务器的原理与实现

### 第十二章：并发编程
1. 基于进程的并发编程       （p682）
    - 父子进程共享状态信息，但每个进程有独立的地址空间
    - 进程见共享信息困难，必须使用显示的进行间通信（IPC）机制
    - 往往运行开销较高，因为进程控制与IPC

2. 基于I/O多路复用的并发编程        (p684)
    - 运行在单一上下文中，每个逻辑流都能访问该进程的全部地址空间
    - 运行更高效，无需进程上下文切换来调度新的流
    - 代码编写复杂，不能充分利用多核处理器

3. 基于线程的并发编程       (p691)
    - 一个进程中的线程组成**对等线程池**，主线程和其他线程区别仅在于它是进程中第一个运行的线程。
    - **可结合线程**
        - 默认情况下线程被创建成可结合的，可以被其他线程收回和杀死，但是在此之前，它的内存资源（比如栈）是不会释放的
    - **分离线程**
        - 一个分离的线程不能被其他线程回收或杀死，其内存资源在它终止时自动释放
    - 为了避免内存泄露，很多应用在创建一线程后，该线程执行的第一个操作就是分离自己

4. 多线程程序中的共享变量       （p696）
    - 线程内存模型
        - 一组并发线程运行在同一个进程的上下文中，理论上任何线程都可以访问共享虚拟内存的任何位置
        - 每个线程都有自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器等（其实和一个函数稍微类似）
        - 线程的栈一般是被自己独立访问的，但是其他线程也可以通过某种方式获得一个指向此线程栈的指针来读写这个栈
    - 全局变量：定义在函数之外，虚拟内存中只包含每个全局变量的一个实例，任何线程都可以使用变量名引用
    - 本地自动变量：定义在函数内部但没有static属性的变量，在每个线程自己的栈中。
    - 本地静态变量：定义在函数内部有static属性，虚拟内存中只包含其唯一实例。

5. 同步错误     （p698）
    - 主要原因：不同进程对同一变量的操作之间存在相互依赖
    - 具体形式举例：两个客户端从github上clone下来两个备份，分别修改后再Push上去，会有一个客户端的工作被覆盖（白做了）
    - 进程图是一种并发线程的执行模型，可以形象的表示出不安全区      (p701)

6. 信号量的使用     （p702）
    - 两种基本操作P操作与V操作
    - 使用信号量实现不同进程对共享资源的**互斥**访问        (p703)
    - 使用信号量实现不同进程对共享资源的访问**调度**        (p704)
        - 理解**生产者-消费者**问题
        - 理解**读者-写者**问题 
    - 基于线程的事件驱动(预线程化)      (p708)

7. 使用线程提高多核处理器上的并行性     (p711)
    - 要尽量避免巨大的同步开销
    - 使用局部变量来避免不必要的内存引用
    - 理解强/弱扩展、加速比、效率等衡量指标

8. 四类线程不安全函数       (p716，书中有提到常见的线程不安全的库函数)
    - 不保护共享变量的函数
    - 保持跨越多个调用的状态的函数
    - 返回指向静态变量的指针的函数
    - 调用线程不安全函数的函数

9. 理解可重入函数（可重入函数肯定是线程安全的）     (p718)
    - 显式可重入：所有函数参数都是传值调用，所有数据引用都是本地的自动栈变量
    - 隐式可重入：允许显式可重入函数传递指向非共享数据的指针

10. 理解竞争与死锁      (p719)

