# 手写数字识别
本程序使用pytorch框架搭建一个卷积神经网络模型来识别手写数字.

## 主要流程
1. 下载数据集并进行预处理

2. 载入训练数据与测试数据(载入后放在一个列表里)

3. 搭建卷积神经网络模型
    - 卷积层+卷积层+最大池化层+扁平化+全连接层+dropout+全连接层
    - 输入数据:28*28*3 ->(卷积层) 28*28*64 ->(卷积层) 28*28*128 ->(pooling层) 14*14*128 ->(view拉平) 一维向量(长度1*14x14x128) ->(全连接) 1*1024 ->(全连接) 1*10 
    - 第一个卷积层有3*3*3*64个权重
    - 第二个卷积层有3*3*64*128个权重 
    - 第一个全连接层有14*14*128*1024个权重 
    - 第二个全连接层有1024*10个权重

4. 定义损失函数与自动优化器

5. 进入迭代优化循环(5个)
    - 得到当前模型在训练数据集上的误差,并进行训练优化
        - 数据输入网络得到前向计算结果
        - 根据损失函数得到loss
        - 根据loss与自动优化器更新网络参数
    - 得到当前模型在测试数据集上的误差

## 数据流变化
1. 数据集阶段：一个大的tensor集合，每个tensor元素由两部分组成，图片+标记

2. 装载阶段：一个大的列表集合，每个元素中有两个tensor，第一个是图像序列，第二个是标记序列（长度为64）
    - 这一部分主要是将数据集集合分批包装，每64个包装成一个大的
    - 装载之后的数据是四维的，第四维是每个包的数据个数

3. 输入网络阶段：
    - 输入网络的数据必须是装载数据，因为装载数据与数据集数据的维度不一样，装载数据多一维
    - 从装载集合中取出一个装载元素，图像部分赋值给一个tensor，标记序列部分赋值给另一个tensor（长度为64的一维序列）
    - 将上述两个tensor转成Variable
    - 将图像Variable输入网络得到output是一个Variable变量，这个变量为64*10的矩阵
    - 64*10矩阵中第n行是这个装载单元里的第n张图片关于10类的预测能量
    - 使用torch.max(data,1)获得data中每一行预测能量最大的那个元素的序号，即是它网络分类预测序号


4. 计算损失
    - 此处使用的损失函数是`torch.nn.CrossEntropyLoss()`
    - 两个参数分别是，网络输出的64*10矩阵，与， 装载数据的1*64标记序列

## `torch.nn.Module`
`torch.nn.Module`类是一个抽象类，代表一个神经网络模型，一般自定义的网络模型都会继承这个类，并且重写以下函数
    - `__init__`: 这个函数主要是复杂网络的模型的初始化
    - `forward`: 重写了这个函数后就可以使用`model(input)`来完成网络的前向计算了

## `torchvision`包
torchvision包的主要功能是实现数据的处理,导入和预览等工作.
- torchvision.datasets: 主要用来下载一些常用的数据集,或者将数据转换成torch可以识别的 dataset 格式

- torchvision.transforms: 主要用来定义数据集的预处理方法.

## `torch.utils.data.DataLoader`包
这个包主要是用来进行数据装载的,比如训练时通常会分批次将数据送入神经网络,这个包就会将数据集分批.

